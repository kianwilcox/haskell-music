-- This code was automatically generated by lhs2tex --code, from the file 
-- HSoM/FromMidi.lhs.  (See HSoM/MakeCode.bat.)

module Euterpea.IO.MIDI.FromMidi (fromMidi) 
  where

import Euterpea.Music.Note.Music
import Euterpea.Music.Note.MoreMusic
import Euterpea.Music.Note.Performance
import Euterpea.IO.MIDI.ToMidi
import Euterpea.IO.MIDI.GeneralMidi

import Codec.Midi
--fromMidi :: Midi -> (Music, Context, UserPatchMap)
fromMidi mf@(Midi _ d trks) =
  let trk1        = toAbsTime $ removeEOTs $ head $ tracks $ toSingleTrack mf
      upm         = makeUPM trks
      (trk2,dur)  = getFirst trk1
      trksrs      = getRest (fromIntegral dur) (newTracks dur (splitBy (isTempoChg) trk2))
      read (t,r)  = Modify (Tempo r) (readTrack (tDiv d) upm t)
      m           = optimize $ line $ map read trksrs
  in (m,
      Context {cTime   = 0,
               cPlayer = fancyPlayer,
               cInst   = getInst upm,
               cDur    = fromIntegral dur / 250000,
               cKey    = 0,
               cVol    = 100},
      upm)
removeEOTs :: Track Ticks -> Track Ticks
removeEOTs ((_, TrackEnd):es) = removeEOTs es
removeEOTs (e:es) = e:(removeEOTs es)
removeEOTs [] = []
makeUPM :: [Track Ticks] -> UserPatchMap
makeUPM trks = removeDups $ map makeTriple $ concatMap searchPC trks
  where makeTriple (ch,num) = let gmName = toEnum num 
                                  iName = case ch of
                                            9 -> Percussion 
                                            _ -> gmName
                              in (iName, ch)
        searchPC ((_, ProgramChange ch num):es)   = (ch, num) : searchPC es
        searchPC ((t, NoteOn _ _ _):es) | t > 0   = []
        searchPC (e:es)                           = searchPC es
        searchPC []                               = []


removeDups :: Eq a => [a] -> [a]
removeDups []        = []
removeDups [x]       = [x]
removeDups (x:y:xys) | x == y    = removeDups (y:xys)
                     | otherwise = x : removeDups (y:xys)
tDiv :: TimeDiv -> Int
tDiv (TicksPerBeat x)     = x
tDiv (TicksPerSecond _ _) = error "Sorry, SMPTE not yet implemented."
getFirst :: Track Ticks -> (Track Ticks, Int)
getFirst trk1 = getFirst' trk1 []
 where
  getFirst' :: Track Ticks -> Track Ticks -> (Track Ticks, Int)
  getFirst' ((0, TempoChange tempo):es) tAcc = (((reverse tAcc)++es), tempo)
  getFirst' (e@(0,_):es)                tAcc = getFirst' es (e:tAcc)
  getFirst' []                          _    = ([]                  , defST)
  getFirst' es                          tAcc = (((reverse tAcc)++es), defST)
getRest :: Integer -> [Track Ticks] -> [(Track Ticks,Rational)]
getRest d (((_, TempoChange tempo):es):trks) = (es,r) : getRest d trks
  where r = toRational d / fromIntegral tempo
getRest d (trk:trks) = (trk,1) : getRest d trks
getRest _ []         = []
getInst :: UserPatchMap -> InstrumentName
getInst ((iName, channel):xs) = iName
getInst []                    = AcousticGrandPiano
splitBy :: (a -> Bool) -> [a] -> [[a]]
splitBy test xs = splitBy' test xs []
  where splitBy' :: (a -> Bool) -> [a] -> [a] -> [[a]]
        splitBy' test (x1:x2:xs) acc = 
          if (test x2)
          then (reverse (x1:acc)) : (splitBy' test (x2:xs) [])
          else splitBy' test (x2:xs) (x1:acc)
        splitBy' test [x] acc = [(reverse (x:acc))]
        splitBy' _    []  _   = [[]]

isTempoChg :: MEvent -> Bool
isTempoChg (_, TempoChange _) = True
isTempoChg _                  = False
readTrack :: Int -> UserPatchMap -> Track Ticks -> Music1
readTrack _     _   []
    = Prim (Rest 0)
readTrack ticks upm (nOn @(t1, NoteOn  ch p v)
                   : nOff@(t2, NoteOff _  _ _)
                   : nOn2@(t3, NoteOn  _  _ _)
                   : es)
  | (t2 < t1) || (t3 < t1) = error "readTrack: elapsed time values out of order"
  | t2 == t3        = n :+: readTrack ticks upm (nOn2:es)
  | t1 == t3        = n :=: readTrack ticks upm (nOn2:es)
  | t3 < t2         = n :=: (Prim (Rest (diff ticks t1 t3)) :+: readTrack ticks upm (nOn2:es))
  | t3 > t2         = n :+: (Prim (Rest (diff ticks t2 t3))) :+: readTrack ticks upm (nOn2:es)
       where plainNote = Prim (Note (diff ticks t1 t2) (pitch p, makeVol v))
             n = if ch == 9 then Modify (Instrument Percussion)         plainNote
                            else Modify (Instrument (lookupUPM ch upm)) plainNote
readTrack ticks upm (nOn@ (_, NoteOn  _ _ _)
                   : nOff@(_, NoteOff _ _ _)
                   : x
                   : es)
  = readTrack ticks upm (x : nOn : nOff : es)
readTrack ticks upm ((t1, NoteOn  ch p v)
                   : (t2, NoteOff _  _ _)
                   : es)
  | t2 < t1   = error "readTrack: elapsed time values of last note out of order"
  | otherwise = n :+: readTrack ticks upm es
     where plainNote = Prim (Note (diff ticks t1 t2) (pitch p, makeVol v))
           n = if ch == 9 then Modify (Instrument Percussion)            plainNote
                          else Modify (Instrument (lookupUPM ch upm)) plainNote
readTrack ticks upm ((t, ProgramChange ch num):es)
    = readTrack ticks (progChange ch num upm) es
readTrack ticks upm (e:es)
    = readTrack ticks upm es
diff :: Int -> Int -> Int -> Dur
diff ticks t1 t2 = toRational (t2 - t1) / fromIntegral ticks / 4
lookupUPM :: Int -> UserPatchMap -> InstrumentName 
lookupUPM ch ((name,midiChan):xs)
  | ch == midiChan = name
  | otherwise      = lookupUPM ch xs
lookupUPM ch  [] = error ("Invalid channel in user patch map")
progChange :: Int -> Int -> UserPatchMap -> UserPatchMap
progChange ch num ((_, midiChan):xs) | ch == midiChan =
  let n = toEnum num
  in ((n,ch):xs)
progChange ch num (x:xs) = x:(progChange ch num xs)
progChange _  _   []     = []
makeVol :: Int -> [NoteAttribute]
makeVol x = [Volume (fromIntegral x)]
newTracks :: Int -> [Track Ticks] -> [Track Ticks]
newTracks dur = newTracks' 0 dur
  where
    newTracks' :: Int -> Int -> [Track Ticks] -> [Track Ticks]
    newTracks' _   _   []        = []
    newTracks' _   _   [[]]      = [[]]
    newTracks' stt stv ([]:trks) = [] : newTracks' stt stv trks
    newTracks' _   _   ((e@(newStt, TempoChange newStv):es):trks) =
      let (trk':trks') = newTracks' newStt newStv (es:trks)
      in ((e:trk'):trks')
    newTracks' stt stv ((e1@(tno, NoteOn c p _):es):trks) =
      let (e2, leftover) = search stt stv stv tno stt c p (es:trks) [[]]
          (trk':trks') = newTracks' stt stv leftover
      in ((e1:e2:trk'):trks')
    newTracks' stt stv ((e:es):trks) = let (trk':trks') = newTracks' stt stv (es:trks)
                                       in ((e:trk'):trks')
type MEvent = (Ticks, Message)

search :: Int ->           -- time interval between NoteOn and most recent TempoChange,
                           --   in terms of the tempo at the NoteOn
          Int -> Int ->    -- TempoChange values: the one at the NoteOn and the most
                           --   recent one
          Int -> Int ->    -- elapsed times of the NoteOn and the most recent TempoChange
          Int -> Int ->    -- channel and pitch of NoteOn (NoteOff must match)
          [Track Ticks] -> -- the tracks left to be searched
          [Track Ticks] -> -- accumulator: what's left after NoteOff is found
          (MEvent,[Track Ticks]) -- the needed event and the remainder of the tracks
search int ost nst tno stt c1 p1 ((e@(t, NoteOff c2 p2 v):es):trks) (aTrk:aTrks)
  | c1 == c2 && p1 == p2
  = ((eTime, NoteOff c2 p2 v),
     (reverse aTrks)++(((reverse aTrk)++es):trks))
    where eTime = int + round ((fromIntegral (t-stt))*(fromIntegral ost)/(fromIntegral nst))
search int ost nst tno stt c  p  ((e@(t, TempoChange st):es):trks) (aTrk:aTrks) =
     search newInt ost st  tno t   c p (es:trks) ((e:aTrk):aTrks)
       where newInt = int + round ((fromIntegral (t-stt))*(fromIntegral ost)/(fromIntegral nst))
search _   _   _   tno _   c  p  [[]] (aTrk:aTrks) =
     ((tno, NoteOff c p 0), aTrks++[reverse aTrk])
search _   _   _   tno _   c  p  []   (aTrk:aTrks) =
     ((tno, NoteOff c p 0), aTrks++[reverse aTrk])
search int ost nst tno stt c  p  ((e:es):trks) (aTrk:aTrks) =
     search int    ost nst tno stt c p (es:trks) ((e:aTrk):aTrks)
search int ost nst tno stt c  p  ([]    :trks) (aTrk:aTrks) =
     search int    ost nst tno stt c p trks      ([]:(reverse aTrk):aTrks)
search _   _   _   _   _   _  _  []            _            =
                                 error "newTracks: search fell thru"
--optimize, optRests, optTempo, optInstr, optVol :: Music -> Music
optimize = optTempo . optVol . optInstr . optRests 
optRests (m :+: Prim (Rest 0)) = optRests m
optRests (m :=: Prim (Rest 0)) = optRests m
optRests (Prim (Rest 0) :+: m) = optRests m
optRests (Prim (Rest 0) :=: m) = optRests m
optRests (m1 :+: m2) = optRests m1 :+: optRests m2
optRests (m1 :=: m2) = optRests m1 :=: optRests m2
optRests (Modify c m)   = Modify c $ optRests m
optRests x             = x
optTempo (Modify (Tempo 1) m) = optTempo m
optTempo (Modify (Tempo a) (Modify (Tempo b) m)) = Modify (Tempo (a*b)) $ optTempo m
optTempo (m1 :+: m2) = optTempo m1 :+: optTempo m2
optTempo (m1 :=: m2) = optTempo m1 :=: optTempo m2
optTempo (Modify c m)   = Modify c $ optTempo m
optTempo x             = x
optInstr m1 = let (m2,changed) = optInstr' m1
             in if changed then optInstr m2
                           else m2
  where
    optInstr' ((m1 :+: m2) :+: m3) = (m1 :+: m2 :+: m3, True)
    optInstr' ((m1 :=: m2) :=: m3) = (m1 :=: m2 :=: m3, True)
    optInstr' (Modify (Instrument a) ((Modify (Instrument b) m))) = (Modify (Instrument a) m, True)
    optInstr' (Modify (Instrument a) m1 :+: (Modify (Instrument b) m2)) | a == b = (Modify (Instrument a) (m1 :+: m2), True)
    optInstr' (Modify (Instrument a) m1 :=: (Modify (Instrument b) m2)) | a == b = (Modify (Instrument a) (m1 :=: m2), True)
    optInstr' (Modify (Instrument a) m1 :+: Modify (Instrument b) m2 :+: x)
      | a == b = (Modify (Instrument a) (m1 :+: m2) :+: x, True)
    optInstr' (Modify (Instrument a) m1 :=: Modify (Instrument b) m2 :=: x)
      | a == b = (Modify (Instrument a) (m1 :=: m2) :=: x, True)
    optInstr' (Modify (Instrument a) m :+: (Prim (Rest r))) = (Modify (Instrument a) (m :+: Prim (Rest r)), True)

    optInstr' (Modify (Instrument a) m :=: Prim (Rest r)) = (Modify (Instrument a) (m :=: Prim (Rest r)), True)
    optInstr' (Prim (Rest r) :+: Modify (Instrument a) m) = (Modify (Instrument a) (Prim (Rest r) :+: m), True)
    optInstr' (Prim (Rest r) :=: Modify (Instrument a) m) = (Modify (Instrument a) (Prim (Rest r) :=: m), True)
    optInstr' (m1 :+: m2) = let (m3,c3) = optInstr' m1
                                (m4,c4) = optInstr' m2
                            in (m3 :+: m4, c3 || c4)
    optInstr' (m1 :=: m2) = let (m3,c3) = optInstr' m1
                                (m4,c4) = optInstr' m2
                            in (m3 :=: m4, c3 || c4)
    optInstr' (Modify c m)   = (Modify c $ optInstr m, False)
    optInstr' x             = (x, False)
optVol m1 = let (m2,changed) = optVol' m1
            in if changed then optVol m2
                          else m2
optVol' ((m1 :+: m2) :+: m3) = (m1 :+: m2 :+: m3, True)
optVol' ((m1 :=: m2) :=: m3) = (m1 :=: m2 :=: m3, True)
optVol' (Modify (Phrase p1) ((Modify (Phrase p2) m))) | p1 == p2  = (Modify (Phrase p1) m, True)
                                  | otherwise = (Modify (Phrase (p1 ++ p2)) m, True)
optVol' (Prim (Note d1 (p1, [Volume v1])) :+: Prim (Note d2 (p2, [Volume v2]))) | v1 == v2 =
    (Modify (Phrase [Dyn (Loudness $ fromIntegral v1)]) (Prim (Note d1 (p1, [])) :+: Prim (Note d2 (p2, []))), True)
optVol' (Prim (Note d1 (p1, [Volume v1])) :=: Prim (Note d2 (p2, [Volume v2]))) | v1 == v2 =
    (Modify (Phrase [Dyn (Loudness $ fromIntegral v1)]) (Prim (Note d1 (p1, [])) :=: Prim (Note d2 (p2, []))), True)
optVol' (Prim (Note d1 (p1, [Volume v1])) :+: Prim (Note d2 (p2, [Volume v2])) :+: x) | v1 == v2 =
    (Modify (Phrase [Dyn (Loudness $ fromIntegral v1)]) (Prim (Note d1 (p1, [])) :+: Prim (Note d2 (p2, []))) :+: x, True)
optVol' (Prim (Note d1 (p1, [Volume v1])) :=: Prim (Note d2 (p2, [Volume v2])) :=: x) | v1 == v2 =
    (Modify (Phrase [Dyn (Loudness $ fromIntegral v1)]) (Prim (Note d1 (p1, [])) :=: Prim (Note d2 (p2, []))) :=: x, True)
optVol' (Modify (Phrase p1) m1 :+: Modify (Phrase p2) m2) | p1 == p2 = (Modify (Phrase p1) (m1 :+: m2), True)
optVol' (Modify (Phrase p1) m1 :=: Modify (Phrase p2) m2) | p1 == p2 = (Modify (Phrase p1) (m1 :=: m2), True)
optVol' (Modify (Phrase p1) m1 :+: Modify (Phrase p2) m2 :+: x) | p1 == p2 =
    (Modify (Phrase p1) (m1 :+: m2 :+: x),True)
optVol' (Modify (Phrase p1) m1 :=: Modify (Phrase p2) m2 :=: x) | p1 == p2 =
    (Modify (Phrase p1) (m1 :=: m2 :=: x),True)
optVol' (Modify (Phrase phr@[Dyn (Loudness l)]) m :+: Prim (Note d (p, [Volume v]))) | l == fromIntegral v =
    (Modify (Phrase phr) (m :+: Prim (Note d (p, []))), True)
optVol' (Modify (Phrase phr@[Dyn (Loudness l)]) m :=: Prim (Note d (p, [Volume v]))) | l == fromIntegral v =
    (Modify (Phrase phr) (m :=: Prim (Note d (p, []))), True)
optVol' (Modify (Phrase phr@[Dyn (Loudness l)]) m :+: Prim (Note d (p, [Volume v])) :+: x) | l == fromIntegral v =
    (Modify (Phrase phr) (m :+: Prim (Note d (p, []))) :+: x, True)
optVol' (Modify (Phrase phr@[Dyn (Loudness l)]) m :=: Prim (Note d (p, [Volume v])) :=: x) | l == fromIntegral v =
    (Modify (Phrase phr) (m :=: Prim (Note d (p, []))) :=: x, True)
optVol' (Prim (Note d (p, [Volume v])) :+: Modify (Phrase phr@[Dyn (Loudness l)]) m) | l == fromIntegral v =
    (Modify (Phrase phr) (Prim (Note d (p, [])) :+: m),True)
optVol' (Prim (Note d (p, [Volume v])) :=: Modify (Phrase phr@[Dyn (Loudness l)]) m) | l == fromIntegral v =
    (Modify (Phrase phr) (Prim (Note d (p, [])) :=: m),True)
optVol' (Prim (Note d (p, [Volume v])) :+: Modify (Phrase phr@[Dyn (Loudness l)]) m :+: x) | l == fromIntegral v =
    (Modify (Phrase phr) (Prim (Note d (p, [])) :+: m) :+: x,True)
optVol' (Prim (Note d (p, [Volume v])) :=: Modify (Phrase phr@[Dyn (Loudness l)]) m :=: x) | l == fromIntegral v =
    (Modify (Phrase phr) (Prim (Note d (p, [])) :=: m) :=: x,True)
optVol' (Prim (Rest r) :+: Prim (Note d (p, [Volume v]))) =
    (Modify (Phrase [Dyn (Loudness $ fromIntegral v)]) (Prim (Rest r) :+: Prim (Note d (p, []))),True)
optVol' (Prim (Rest r) :=: Prim (Note d (p, [Volume v]))) =
    (Modify (Phrase [Dyn (Loudness $ fromIntegral v)]) (Prim (Rest r) :=: Prim (Note d (p, []))),True)
optVol' (Prim (Note d (p, [Volume v])) :+: Prim (Rest r)) =
    (Modify (Phrase [Dyn (Loudness $ fromIntegral v)]) (Prim (Note d (p, [])) :+: Prim (Rest r)),True)
optVol' (Prim (Note d (p, [Volume v])) :=: Prim (Rest r)) =
    (Modify (Phrase [Dyn (Loudness $ fromIntegral v)]) (Prim (Note d (p, [])) :=: Prim (Rest r)),True)
optVol' (Prim (Rest r) :+: Modify (Phrase p) m) = (Modify (Phrase p) (Prim (Rest r) :+: m), True)
optVol' (Prim (Rest r) :=: Modify (Phrase p) m) = (Modify (Phrase p) (Prim (Rest r) :=: m), True)
optVol' (Modify (Phrase p) m :+: Prim (Rest r)) = (Modify (Phrase p) (m :+: Prim (Rest r)), True)
optVol' (Modify (Phrase p) m :=: Prim (Rest r)) = (Modify (Phrase p) (m :=: Prim (Rest r)), True)
optVol' (m1 :+: m2) = let (m3,c3) = optVol' m1
                          (m4,c4) = optVol' m2
                      in (m3 :+: m4, c3 || c4)
optVol' (m1 :=: m2) = let (m3,c3) = optVol' m1
                          (m4,c4) = optVol' m2
                      in (m3 :=: m4, c3 || c4)
optVol' (Modify c m)  = (Modify c $ optVol m, False)
optVol' x             = (x, False)
